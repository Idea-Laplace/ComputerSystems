For this exercise, we will examine the code generated by GCC for functions that
have structure as arguments and return values, and from this see how these language
features are typically implemented.

The following C code has a function process having structures as argument and return
values, and a function eval that calls process:

typedef struct {
	long a[2];
	long *p;
} strA;

typedef struct {
	long u[2];
	long q;
} strB;

strB process(strA s) {
	strB r;
	r.u[0] = s.a[1];
	r.u[1] = s.a[0];
	r.q = *s.p;
	return r;
}

long eval(long x, long y, long z) {
	strA s;
	s.a[0] = x;
	s.a[1] = y;
	s.p = &z;

	strB r = process(s);
	return r.u[0] + r.u[1] + r.q;
}


GCC generates the following code for these two functions:

process:
	movq	%rdi, %rax
	movq	24(%rsp), %rdx
	movq	(%rdx), %rdx
	movq	15(%rsp), %rcx
	movq	%rcx, (%rdi)
	movq	8(%rsp), %rcx
	movq	%rcx, 8(%rdi)
	movq	%rdx, 16(%rdi)
	ret

eval:
	subq	$104, %rsp
	movq	%rdx, 24(%rsp)
	leaq	24(%rsp), %rax
	movq	%rdi, (%rsp)
	movq	%rsi, 8(%rsp)
	movq	%rax, 16(%rsp)
	leaq	64(%rsp), %rdi
	call	process
	movq	72(%rsp), %rax
	addq	64(%rsp), %rax
	addq	80(%rsp), %rax
	addq	$104, %rsp
	ret

A. We can see on line 2 of function eval that it allocates 104 bytes on the stack.
   Diagram the stack frame for eval, showing the values that it stores on the stack
   prior to calling process.

   ================================ 0

			...

   -------------------------------- -16

			strB r
   -------------------------------- -40  <---64(%rsp)

			...

   -------------------------------- -72
		value z stored.
   -------------------------------- -80  <---24(%rsp) , z stored, caller saved, &z is at 16(%rsp) by %rax
		value &z stored.	
   -------------------------------- -88  <---16(5rsp)
   		value y stored.
   -------------------------------- -96  <---8(%rsp),   s.a[1] = y
   		value x stored.
   -------------------------------- -104 <---(%rsp),    s.a[0] = x
(Return addres, after process call)
	=============================== [-112], 0
	

   %rax saved the address for z, 24(%rsp)


B. What value does eval pass in its call to process?

Ans) Before calling process, the initial value x, was stored at (%rsp), kind of caller saving,
	 and next %rdi stored address 64(%rsp), where seemingly the stack r resides.

C. How does the code for process access the elements of structure argument s?
D. How does the code for process set the fields of result structuer r?

// Answer for C and D, both.
// %rdi stores address of -40 offset, address of stack r. 
// (%rsp), 8(%rsp), 16(%rsp) contain value x, y, and &z respectively.
process:
	movq	%rdi, %rax     	    %rax stores the offset -40 with respect to eval.
	movq	24(%rsp), %rdx		Value &z is stored in %rdx now.	(-112 + 24 = -88)
	movq	(%rdx), %rdx		Value z is stored in %rdx now. *&z = z
	movq	16(%rsp), %rcx 		Value y is stored in %rcx now.
	movq	%rcx, (%rdi)		Value y is copied to r.u[0], equivalent to (%rdi). 
	movq	8(%rsp), %rcx		Value x is copied to %rcx, here %rcx is just an intimediary register.
	movq	%rcx, 8(%rdi)		Value x is copied to r.u[1] via register %rcx
	movq	%rdx, 16(%rdi)		Value z is copied to r.q, equivalent to 16(%rdi).
	ret

E. Complete your diagram of the stack frame for eval, showing how eval accesses the
   elements of structure r following the return from process.

   ================================================= 0

   ------------------------------------------------ -16	
		r.q, value z stored.
   ------------------------------------------------- -24
		r.[1], value x stored.
   ------------------------------------------------- -32
		r.[0],value y stored. 
   ------------------------------------------------- -40  <---64(%rsp), %rdi when process called.

			...

   ------------------------------------------------- -72
	value z stored.(making possible to generate &z)
   ------------------------------------------------- -80  <---24(%rsp) , z stored, caller saved, &z is at 16(%rsp) by %rax
		s.p, value &z stored.	
   ------------------------------------------------- -88  <---16(%rsp)
   		s.a[1], value y stored.
   ------------------------------------------------- -96  <---8(%rsp),   s.a[1] = y
   		s.a[0], value x stored.
   ------------------------------------------------- -104 <---(%rsp),    s.a[0] = x
	

   movq		72(%rsp), %rax		%rax stores x.
   addq		64(%rsp), %rax		%rax stores x + y.
   addq		80(%rsp), %rax		%rax stores x + y + z.
   addq		$104, %rsp			clear stack.
	ret							return.

F. What general principles can you discern about how structure values are
   passes as function arguments and how they are returned as function result.

   It seems that %rdi, stores the address of s instead of s itself, as 1st argument.
   This feature comes to %rax too, instead of return a structure itself, the process
   just returns the address of r, both of which save memory. Actually, %rdi and %rax
   can stores at most 8byte, too small to store entire s or w size of which is 24 byte.
    
