    In our design of PIPE, we generate a stall whenever one instruction performs
a load, reading a value from memory into a register, and the next instruction has
this register as a source operand. When the source gets used in the execute stage,
this stalling is the only way to avoid a hazard. For cases where the second instr-
-uction stores the source operand to memory, such as with an rmmovq or pushq inst-
-ruction, this stalling is not necessary. Consider the following code examples:

mrmovq  0(%rcx), %rdx
pushq   %rdx
nop
popq    %rdx
rmmovq  %rax, 0(%rdx)

In lines 1 and 2, the mrmovq instruction reads a value from memory into %rdx, and
the pushq instrucion then pushes this value onto the stack. Our design for PIPE
would stall the pushq instrucion to avoid a load/use hazard. Observe, however, that
the value of %rdx is not required by the pushq instruction until it reaches the
memory stage. We can add an additional bypass path, as diagrammed in Figure 4.70,
to forward the memory output(signal m_valM) to the valA field in pipeline register M.
On the next clock cycle, this forwarded values can then be written to memory. This
technique is known as load forwarding.
    Note that the second example (line 4-5) in the code sequence above cannot use of
load forwarding. The value loaded by the popq instruction is used as part of the
address computation by the next instruction, and this value is required in the execute
stage rather than the memory stage.

A. Write a logic formula describing the detection condition for a load/use hazard,
   similar to the one given in Figure 4.64, except that it will not cause a stall
   in cases where load forwarding can be used.

    Figure 4.64

    Load/use hazard:
    E_icode in { IMRMOVQ, IPOPQ } && E_dstM in { d_srcA, d_srcB };

sol)
    Even if E_dstM happens to be d_srcA or d_srcB, when the value is guaranteed to
    be used only after execution stage, we can avoid load/use hazard.
    This exception only occurs in d_srcA, valB from d_srcB is always aluB.

    E_icode in { IMRMOVQ, IPOPQ } &&
    (E_dstM == d_srcA && !(D_icode in { IRMMOVQ, IPUSHQ }) || E_dstM == d_srcB);


B. The file pipe-lf.hcl contains a modified version of the control logic for PIPE.
   It contains the definition of a signal e_valA to implement the block labeled
   'Fwd A' in Figure 4.70. It also has the conditions for a load/use hazard in the
   pipeline control logic set to 0, and so the pipeline control logic will not detect
   any forms of load/use hazards. Modify this HCL description to implement load
   forwarding. See the lab material for directions on how to generate a simulator
   four your solution and how to test it.
