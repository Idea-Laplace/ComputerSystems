One common pattern in machine-level programs is to add a constant value
to a register. With the Y86-64 instructions presented thus far, this requires
first using an irmovq instruction to set a register to the constant, and then
an addq instruction to add this value to the destination register. Suppose we
want to add a new instruction iaddq with the following format:

Byte			0	1	2	3	4	5	6	7	8	9	|
iaddq V, rB		C 0 F rB                 V

This instruction adds the constant value V to register B

Rewrite the Y86-64 sum function of Figure 4.6 to make use of
the iaddq instruction. In the original version, we dedicated registers
%r8 and %r9 to hold constant values. Now, we can avoid using those registers altogether.


Original
----------------------------------------------------------------------------------------------
sum:
	irmovq $8, %r8			# Constant 8, address increment by 8.
	irmovq $1, %r9			# Constant 1, 'count' parameter decrement by 1.
	xorq %rax, %rax			# Initialization of return value with 0.
	andq %rsi, %rsi			# Set up Zero Flag(either 0 or 1).
	jmp test				
loop:
	mrmovq (%rdi), %r10		# Move arr[0] to %r10 register.
	addq %r10, %rax			# Sum.
	addq %r8, %rdi			# Address increases by its word size(8 here.)
	subq %r9, %rsi			# count-- (toward 0), so count should be nonnegative for this program to be properly terminated, and set CC
test:
	jne loop				# Loop when count is nonzero.
	ret
----------------------------------------------------------------------------------------------

Rewrite
----------------------------------------------------------------------------------------------
sum:
	xorq %rax, %rax
	andq %rsi, %rsi
	jmp test
loop:
	mrmovq (%rdi), %rdx
	addq %rdx, %rax
	iaddq $8, %rdi
	iaddq $-1, %rsi
test:
	jne loop
	ret
----------------------------------------------------------------------------------------------
